---
title: "testing"
output: html_document
date: "2025-08-18"
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/Users/4470246/Repositories/NeutralKaryotypes")
```


```{r}
ids <- readLines("karyotyped_samples.txt")
ids=grep("HGC",ids,value=T, invert = T)
ids=grep("_r",ids,value=T, invert = T)
ids=grep("_K",ids,value=T, invert = T)

mrcas <- c("MDA-MB-231_RPMI_A12_VT2_seed", 
           "SNU-668_C_A4_seed",
           "SNU-668_RevC_A3_seed",
           "SUM-159_NLS_2N_MRCA_harvest",
           "SUM-159_NLS_4N_MRCA_harvest")

ids = setdiff(ids,mrcas)
```

```{r}
require(DBI)
require(RMariaDB)
source("R/db_utils.R")
dbvars <- load_db_vars("db_creds.txt")
db <- dbConnect(
    MariaDB(),
    host = dbvars["HOST"],
    user = dbvars["USER"],
    password = dbvars["PASSWORD"],
    dbname = dbvars["DBNAME"]
)

x <- dbGetQuery(db, "SELECT * FROM Passaging")
m <- dbGetQuery(db,"SELECT * FROM Media")

```

```{r}

find_all_ancestors <- function(id,g){
  ids <- c()
    while(!is.na(id)){
      ids <- c(id,ids)
      id <- g$passaged_from_id1[g$id==id]
    }
  return(ids)
}

mrca_an <- lapply(mrcas,find_all_ancestors,g=x)
id_an <- lapply(ids,find_all_ancestors,g=x)

## which mrca belongs to each id?
## Map each endpoint to the closest proxy MRCA based on the deepest shared branch point
id_map <- lapply(id_an, function(lin1) {
  
  end_id <- tail(lin1, 1)
  
  # 1. Calculate how many ancestral nodes lin1 shares with each proxy MRCA
  shared_path_lengths <- sapply(mrca_an, function(lin2) {
    min_len <- min(length(lin1), length(lin2))
    matches <- lin1[1:min_len] == lin2[1:min_len]
    if (all(matches)) {
      return(min_len)
    } else {
      return(which(!matches)[1] - 1)
    }
  })
  
  # 2. Find all proxy MRCAs that tied for the longest shared path
  max_len <- max(shared_path_lengths)
  tied_indices <- which(shared_path_lengths == max_len)
  
  # 3. If there is a topological tie, break it by string similarity
  if (length(tied_indices) > 1) {
    tied_mrcas <- mrcas[tied_indices]
    
    # Calculate Levenshtein string distance using R's built-in adist()
    # The smallest distance = most biologically similar name 
    # (e.g., SNU-668_RevG will mathematically pair with SNU-668_RevC)
    dists <- as.numeric(adist(end_id, tied_mrcas))
    
    # Pick the index of the most similar MRCA string
    best_tie_idx <- which.min(dists)
    final_ix <- tied_indices[best_tie_idx]
  } else {
    final_ix <- tied_indices[1]
  }
  
  list(
    id_start = mrcas[final_ix], 
    id_end = end_id
  )
})


```

```{r}
karyotypes <- get_karyotyping(c(mrcas,ids))
```

```{r}
source("R/estimate_pmis.R")

# --- Helper to merge Replicate Names ---
get_condition_name <- function(id_string) {
  
  # 1. Fix known typos (Handling Point 4)
  # Fixes the lowercase 'k' in "A18k" so it matches "A18K"
  id_string <- gsub("A18k", "A18K", id_string)
  
  # 2. Strict Replicate Merging
  # Target: Underscore + (O, Q, G, P, r, or K) + Digits + Underscore
  # Replacement: Underscore + Letter + Underscore
  # This EXCLUDES 'A' (Clone IDs) and 'C' (Condition IDs) so numbers aren't stripped from them.
  gsub("_([OQGPrK])[0-9]+_", "_\\1_", id_string)
}

# --- Group IDs by Biological Condition ---
names(id_map) <- sapply(id_map, function(x) x$id_end)
conditions <- sapply(names(id_map), get_condition_name)
grouped_map <- split(id_map, conditions)

# --- Create Merged Fit Objects ---
fit_objects <- lapply(names(grouped_map), function(cond_name) {
  group <- grouped_map[[cond_name]]
  
  # Validation: Ensure all replicates map to the same Ancestor
  mrcas <- unique(sapply(group, function(x) x$id_start))
  if(length(mrcas) > 1) {
    warning(paste("Skipping", cond_name, "- Replicates map to different MRCAs:", paste(mrcas, collapse=", ")))
    return(NULL)
  }
  
  # Get Ancestor (K0)
  id_start <- group[[1]]$id_start
  K0 <- do.call(rbind, karyotypes$karyotype[karyotypes$id == id_start])
  if(is.null(K0)) return(NULL) # Safety check
  
  # Merge Target Karyotypes (KT)
  KT_list <- lapply(group, function(x) {
    if(!x$id_end %in% karyotypes$id) return(NULL)
    do.call(rbind, karyotypes$karyotype[karyotypes$id == x$id_end])
  })
  
  KT_list <- KT_list[!sapply(KT_list, is.null)]
  if(length(KT_list) == 0) return(NULL)
  
  #Assign the actual replicate names to the list before merging
  names(KT_list) <- sapply(group, function(x) x$id_end)
  
  KT_merged <- do.call(rbind, KT_list)
  HT_merged <- hist_mat_from_matrix(round(KT_merged))
  H0 <- hist_mat_from_matrix(round(K0))
  
  # Calculate Time (Delta Pass)
  pass_start <- x$passage[x$id == id_start]
  pass_ends <- sapply(group, function(item) x$passage[x$id == item$id_end])
  
  if (any(is.na(pass_ends))) return(NULL)
  delta_pass <- mean(pass_ends) - pass_start
  
  list(
    id_start = id_start,
    id_end = cond_name,       
    replicates = names(group),
    K0 = K0,
    KT = KT_merged,           
    KT_list = KT_list,        # <--- NEW: Store the unmerged matrices here
    H0 = H0,
    HT = HT_merged,
    delta_pass = delta_pass
  )
})

# Filter Nulls and Save
fit_objects <- fit_objects[!sapply(fit_objects, is.null)]
saveRDS(fit_objects, "fit_objects.Rds")

# 
# 
# fit_objects <- lapply(id_map,function(id){
#   
#   id$K0 <- do.call(rbind,karyotypes$karyotype[karyotypes$id==id$id_start])
#   if(!id$id_end%in%karyotypes$id){
#     print(id$id_end)
#     return(NULL)
#   }
#   id$KT <- do.call(rbind,karyotypes$karyotype[karyotypes$id==id$id_end])
#   
#   id$H0 <- hist_mat_from_matrix(round(id$K0))
#   id$HT <- hist_mat_from_matrix(round(id$KT))
#   
#   id$delta_pass <- x$passage[x$id==id$id_end]-x$passage[x$id==id$id_start]
#   id
# })
# fit_objects <- fit_objects[!sapply(fit_objects,is.null)]
# saveRDS(fit_objects,"fit_objects.Rds")
```

```{r}
# --- Execute the Local Simulation Pipeline ---
# This runs the logic from R/run_local.R, processing all samples in fit_objects.Rds
# It effectively replaces the Slurm submission step.

message("Starting local simulation pipeline...")
source("R/run_local.R")
message("Simulation pipeline complete.")
```

```{r}
# --- Collect Results and Save to CSV ---
ff <- list.files("data/fits/", full.names = TRUE)

df_list <- lapply(ff, function(fi){
  res <- readRDS(fi)
  if(!"test_null_res" %in% names(res)) return(NULL)
  
  # Get the Joint Best-Fit CIN Rate
  best_idx <- which.min(res$resdf$negll)
  best_cin_rate <- res$resdf$pmis[best_idx]
  
  # Create a row for EACH independent replicate
  replicate_rows <- lapply(names(res$test_null_res$individuals), function(rep_name) {
    rep_res <- res$test_null_res$individuals[[rep_name]]
    
    data.frame(
      condition = res$id_end,       # e.g., SUM..._O_harvest
      replicate_id = rep_name,      # e.g., SUM..._O1_harvest
      ancestor = res$id_start,
      p_value = rep_res$empp,       # Independent p-value for THIS flask
      cin_rate = best_cin_rate,     # The joint mechanistic rate
      delta_pass = res$delta_pass
    )
  })
  
  do.call(rbind, replicate_rows)
})

# Combine all lists, sort, and save
df <- do.call(rbind, df_list)
df <- df[order(df$condition),]
data.table::fwrite(df, "data/neutral_probability.csv", sep=",")

# Preview
print(head(df))

```

```{r}
x <- readRDS("data/fits/MDA-MB-231_G1_A4_seed.Rds")
y <- readRDS("data/pops/MDA-MB-231_G1_A4_seed.Rds")
```


```{r}
KT <- round(x$KT)
image(hist_mat_from_named_counts(y[[1]]))
image(x$H0)
image(x$HT)
pop <- y[1:50]

library(transport)
  
  sampleToInt <- function(pp, Nsam=20) {
    samstr <- sample(names(pp), size = Nsam, prob = pp)
    samstr <- table(samstr)
    # Ensure consistent matrix dimensions for 22 chromosomes/bins
    coords <- matrix(as.numeric(unlist(strsplit(names(samstr), split="[.]"))), ncol=22, byrow = TRUE)
    list(coords = coords, counts = samstr)
  }
  
  Nsam <- nrow(KT)
  
  # Process Target (KT)
  samstr <- table(apply(KT, 1, paste, collapse="."))
  smm <- list(
    coords = matrix(as.numeric(unlist(strsplit(names(samstr), split="[.]"))), ncol=22, byrow = TRUE),
    counts = samstr
  )
  wtst <- wpp(smm$coords, mass = smm$counts)
  
  # 1. Internal distances (Null distribution)
  dnull <- sapply(1:length(pop), function(i) {
    sapply(1:length(pop), function(j) {
      if (i >= j) return(NaN)
      
      popi <- sampleToInt(pop[[i]], Nsam)
      popj <- sampleToInt(pop[[j]], Nsam)
      
      wi <- wpp(popi$coords, mass = popi$counts)
      wj <- wpp(popj$coords, mass = popj$counts)
      
      wasserstein(wi, wj)
    })
  })
  dnull <- dnull[is.finite(dnull)]
  
  # 2. Test distances (Populations vs Target)
  dtst <- sapply(1:length(pop), function(j) {
    popj <- sampleToInt(pop[[j]], Nsam)
    
    wj <- wpp(popj$coords, mass = popj$counts)
    wasserstein(wj, wtst)
  })
  
  tst_stat <- median(dtst)
  empp <- mean(dnull > tst_stat)

```

